import { createClient } from '@/lib/supabase/server'
import { NextRequest, NextResponse } from 'next/server'
import puppeteer from 'puppeteer-core'
import chromium from '@sparticuz/chromium-min'
import { postProcessLLMOutput, replaceTBDPlaceholders } from '@/lib/utils/textPostProcessor'
import { marked } from 'marked'
import { openai } from '@/lib/openai/client'
import { getPrompts } from '@/lib/openai/prompts'

// PDF labels for each locale
const getPdfLabels = (locale: string) => {
  const isEnglish = locale === 'en'
  return {
    exhibitionPlanning: isEnglish ? 'Exhibition Planning' : '전시 기획',
    exhibitionKeywords: isEnglish ? 'Exhibition Keywords' : '전시 키워드',
    exhibitionPoster: isEnglish ? 'Exhibition Poster' : '전시 포스터',
    exhibitionIntroduction: isEnglish ? 'Exhibition Introduction' : '전시 소개',
    exhibitionPreface: isEnglish ? 'Exhibition Preface' : '전시 서문',
    artistBio: isEnglish ? 'Artist Biography' : '작가 소개',
    artworks: isEnglish ? 'Artworks' : '작품',
    artwork: isEnglish ? 'Artwork' : '작품',
    pressRelease: isEnglish ? 'Press Release' : '보도자료',
    marketingReport: isEnglish ? 'Marketing Report' : '마케팅 리포트',
    untitled: isEnglish ? 'Untitled' : '제목 없음',
    generatedBy: 'Generated by Art Wizard',
    targetAudience: isEnglish ? 'Target Audience' : '주요 타깃',
    marketingPoints: isEnglish ? 'Marketing Points' : '마케팅 포인트',
    pricingStrategy: isEnglish ? 'Pricing Strategy' : '가격 전략',
    promotionStrategy: isEnglish ? 'Promotion Strategy' : '추천 홍보 전략',
  }
}

// Configure marked for safe HTML output
marked.setOptions({
  breaks: true, // Convert \n to <br>
  gfm: true, // GitHub Flavored Markdown
})

// Remote chromium URL for Vercel serverless (official Sparticuz release)
const CHROMIUM_URL = 'https://github.com/Sparticuz/chromium/releases/download/v131.0.0/chromium-v131.0.0-pack.tar'

export async function POST(req: NextRequest) {
  let browser = null
  try {
    let requestBody
    try {
      requestBody = await req.json()
    } catch (parseError) {
      console.error('[PDF] Failed to parse request body:', parseError)
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 })
    }

    const { exhibitionId, locale = 'ko' } = requestBody
    const labels = getPdfLabels(locale)
    const PROMPTS = getPrompts(locale)

    if (!exhibitionId) {
      console.error('[PDF] Missing exhibition ID')
      return NextResponse.json(
        { error: 'Exhibition ID is required' },
        { status: 400 }
      )
    }

    console.log('[PDF] Starting PDF generation for exhibition:', exhibitionId)
    const supabase = await createClient()

    // Check authentication
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Fetch exhibition data
    const { data: exhibition, error: exhibitionError } = await supabase
      .from('exhibitions')
      .select('*')
      .eq('id', exhibitionId)
      .single()

    if (exhibitionError || !exhibition) {
      return NextResponse.json(
        { error: 'Exhibition not found' },
        { status: 404 }
      )
    }

    console.log('[PDF] curator_conversation:', exhibition.curator_conversation?.length || 0, 'messages')
    if (exhibition.curator_conversation?.length > 0) {
      console.log('[PDF] First message:', JSON.stringify(exhibition.curator_conversation[0]).substring(0, 100))
    }

    // Summarize conversation if exists
    let conversationSummary = ''
    if (exhibition.curator_conversation && exhibition.curator_conversation.length > 0) {
      try {
        console.log('[PDF] Summarizing conversation...')
        const summaryResponse = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: [
            {
              role: 'system',
              content: PROMPTS.summarizeConversation(exhibition.curator_conversation, exhibition.title || labels.untitled)
            }
          ],
          temperature: 0.5,
          max_tokens: 1000,
        })

        const summaryText = summaryResponse.choices[0]?.message?.content || ''
        try {
          const parsed = JSON.parse(summaryText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim())
          conversationSummary = parsed.summary || ''
        } catch {
          conversationSummary = summaryText
        }
        console.log('[PDF] Conversation summary generated:', conversationSummary.substring(0, 100))
      } catch (error) {
        console.error('[PDF] Failed to summarize conversation:', error)
      }
    }

    // Fetch exhibition content
    const { data: content } = await supabase
      .from('exhibition_content')
      .select('*')
      .eq('exhibition_id', exhibitionId)

    console.log('[PDF] exhibition_content types found:', content?.map(c => c.content_type))

    // Fetch artworks
    const { data: artworks } = await supabase
      .from('artworks')
      .select('*')
      .eq('exhibition_id', exhibitionId)
      .order('order_index', { ascending: true })

    console.log('[PDF] Artworks found:', artworks?.length || 0, artworks?.map(a => ({ title: a.title, desc: a.description?.substring(0, 30) })))

    // Fetch posters - get the latest poster (not filtering by is_primary to ensure we always get one)
    const { data: posters, error: postersError } = await supabase
      .from('posters')
      .select('*')
      .eq('exhibition_id', exhibitionId)
      .order('created_at', { ascending: false })
      .limit(1)

    console.log('[PDF] Posters found:', posters?.length || 0, postersError ? `Error: ${postersError.message}` : '')

    // Content mapping helper with post-processing for gender-neutral language
    const getContent = (type: string) => {
      // Check for both snake_case and camelCase versions (database has inconsistent naming)
      const snakeCase = type
      const camelCase = type.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())

      const item = content?.find((c: any) =>
        c.content_type === snakeCase || c.content_type === camelCase
      )
      if (!item?.content) return ''

      // Handle marketing report object format (saved directly as object, not wrapped in {text: ...})
      if (type === 'marketing_report' && typeof item.content === 'object' && !item.content.text) {
        const mr = item.content
        let formatted = ''
        if (mr.overview) formatted += mr.overview + '<br><br>'
        if (mr.targetAudience?.length) formatted += `<strong>${labels.targetAudience}:</strong><br>` + mr.targetAudience.join('<br>') + '<br><br>'
        if (mr.marketingPoints?.length) formatted += `<strong>${labels.marketingPoints}:</strong><br>` + mr.marketingPoints.join('<br>') + '<br><br>'
        if (mr.pricingStrategy) formatted += `<strong>${labels.pricingStrategy}:</strong><br>` + mr.pricingStrategy + '<br><br>'
        if (mr.promotionStrategy?.length) formatted += `<strong>${labels.promotionStrategy}:</strong><br>` + mr.promotionStrategy.join('<br>')

        let result = formatted.trim()
        result = postProcessLLMOutput(result)
        result = replaceTBDPlaceholders(result, {
          exhibition_date: exhibition.exhibition_date,
          exhibition_end_date: exhibition.exhibition_end_date,
          venue: exhibition.venue,
          location: exhibition.location,
          admission_fee: exhibition.admission_fee,
        })
        return result
      }

      let text = typeof item.content === 'string' ? item.content : item.content.text || ''
      let result = text

      // Remove JSON formatting if present
      if (text.trim().startsWith('{') || text.trim().startsWith('```json')) {
        try {
          // Remove markdown code block if present
          text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim()

          // Try to parse as JSON
          const parsed = JSON.parse(text)

          // Extract the actual content from common JSON response formats
          if (parsed.artistBio) result = parsed.artistBio
          else if (parsed.introduction) result = parsed.introduction
          else if (parsed.preface) result = parsed.preface
          else if (parsed.pressRelease) result = parsed.pressRelease
          else if (parsed.marketingReport) {
            // Format marketing report if it's an object
            if (typeof parsed.marketingReport === 'object') {
              const mr = parsed.marketingReport
              let formatted = ''
              if (mr.overview) formatted += mr.overview + '<br><br>'
              if (mr.targetAudience) formatted += `<strong>${labels.targetAudience}:</strong><br>` + mr.targetAudience.join('<br>') + '<br><br>'
              if (mr.marketingPoints) formatted += `<strong>${labels.marketingPoints}:</strong><br>` + mr.marketingPoints.join('<br>') + '<br><br>'
              if (mr.pricingStrategy) formatted += `<strong>${labels.pricingStrategy}:</strong><br>` + mr.pricingStrategy + '<br><br>'
              if (mr.promotionStrategy) formatted += `<strong>${labels.promotionStrategy}:</strong><br>` + mr.promotionStrategy.join('<br>')
              result = formatted.trim()
            } else {
              result = parsed.marketingReport
            }
          }
        } catch (e) {
          // If parsing fails, use original text
          result = text
        }
      }

      // Apply post-processing: removes gendered language, cleans JSON artifacts, markdown, typos
      result = postProcessLLMOutput(result)

      // Replace [TBD] placeholders with actual exhibition data
      result = replaceTBDPlaceholders(result, {
        exhibition_date: exhibition.exhibition_date,
        exhibition_end_date: exhibition.exhibition_end_date,
        venue: exhibition.venue,
        location: exhibition.location,
        admission_fee: exhibition.admission_fee,
      })

      // Convert markdown to HTML
      result = marked.parse(result) as string

      return result
    }

    // Create HTML with Korean font support
    const htmlContent = `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <style>
          @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

          * { margin: 0; padding: 0; box-sizing: border-box; }

          body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            line-height: 1.8;
            color: #1E293B;
            background: #fff;
          }

          @page:first {
            margin: 0;
          }

          .page {
            page-break-before: always;
          }

          .cover {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #F5F3F0 0%, #E8E0D5 100%);
            min-height: 100vh;
            width: 100vw;
            position: relative;
            left: 50%;
            right: 50%;
            margin-left: -50vw;
            margin-right: -50vw;
            padding: 80px 60px;
          }

          h1 {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 30px;
            color: #1E293B;
            letter-spacing: -0.02em;
          }

          .keywords {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 30px 0;
          }

          .keyword {
            background: #fff;
            padding: 8px 20px;
            border-radius: 24px;
            font-size: 14px;
            color: #64748B;
            border: 1px solid #D4C5B9;
          }

          h2 {
            font-size: 32px;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 24px;
            color: #1E293B;
            border-bottom: 2px solid #D4C5B9;
            padding-bottom: 12px;
          }

          h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 24px 0 12px;
            color: #334155;
          }

          p {
            font-size: 16px;
            line-height: 1.9;
            margin-bottom: 20px;
            color: #475569;
            text-align: justify;
            word-break: keep-all;
          }

          /* Markdown content styles */
          .content-area {
            font-size: 16px;
            line-height: 1.9;
            color: #475569;
          }

          .content-area h1, .content-area h2, .content-area h3 {
            margin-top: 24px;
            margin-bottom: 12px;
            color: #1E293B;
          }

          .content-area h1 { font-size: 24px; }
          .content-area h2 { font-size: 20px; border-bottom: none; }
          .content-area h3 { font-size: 18px; }

          .content-area ul, .content-area ol {
            margin: 16px 0;
            padding-left: 24px;
          }

          .content-area li {
            margin-bottom: 8px;
          }

          .content-area strong {
            color: #1E293B;
            font-weight: 600;
          }

          .content-area blockquote {
            border-left: 4px solid #D4C5B9;
            padding-left: 16px;
            margin: 16px 0;
            color: #64748B;
            font-style: italic;
          }

          .artworks-grid {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 48px;
          }

          .artwork-item {
            width: 100%;
            max-width: 600px;
            text-align: center;
            page-break-inside: avoid;
            margin-bottom: 32px;
          }

          .artwork-item img {
            max-width: 100%;
            max-height: 300px;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 4px;
            margin-bottom: 16px;
          }

          .artwork-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #000000;
          }

          .artwork-desc {
            font-size: 16px;
            color: #000000;
            line-height: 1.6;
          }

          .planning-section {
            background: #F8F9FA;
            padding: 32px;
            border-radius: 8px;
            margin-top: 24px;
          }

          .planning-section p {
            margin: 12px 0;
            font-size: 16px;
          }

          .planning-section strong {
            color: #1E293B;
          }

          .poster-page {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 70vh;
          }

          .poster-page img {
            max-width: 80%;
            max-height: 65vh;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
          }

          .footer {
            margin-top: 60px;
            padding-top: 24px;
            border-top: 1px solid #E2E8F0;
            text-align: center;
            font-size: 14px;
            color: #94A3B8;
          }
        </style>
      </head>
      <body>
        <!-- Cover Page -->
        <div class="page cover">
          <h1>${exhibition.title || labels.untitled}</h1>
          ${
            exhibition.keywords && exhibition.keywords.length > 0
              ? `<div class="keywords">${exhibition.keywords.map((k: string) => `<span class="keyword">${k}</span>`).join('')}</div>`
              : ''
          }
          <div class="footer">
            <p>${labels.generatedBy}</p>
            <p>${new Date().toLocaleDateString(locale === 'en' ? 'en-US' : 'ko-KR')}</p>
          </div>
        </div>

        <!-- Exhibition Planning -->
        <div class="page">
          <h2>${labels.exhibitionPlanning}</h2>

          <div class="planning-section">
            ${exhibition.keywords && exhibition.keywords.length > 0 ? `<p><strong>${labels.exhibitionKeywords}:</strong> ${exhibition.keywords.join(', ')}</p>` : ''}

            ${conversationSummary ? `
              <div class="content-area" style="margin-top: 24px;">
                ${marked.parse(conversationSummary)}
              </div>
            ` : ''}
          </div>
        </div>

        <!-- Main Poster -->
        ${
          posters && posters.length > 0 && posters[0].image_url
            ? `
        <div class="page">
          <h2>${labels.exhibitionPoster}</h2>
          <div class="poster-page">
            <img src="${posters[0].image_url}" alt="Exhibition Poster">
          </div>
        </div>
        `
            : ''
        }

        <!-- Introduction -->
        ${
          getContent('introduction')
            ? `
        <div class="page">
          <h2>${labels.exhibitionIntroduction}</h2>
          <div class="content-area">${getContent('introduction')}</div>
        </div>
        `
            : ''
        }

        <!-- Preface -->
        ${
          getContent('preface')
            ? `
        <div class="page">
          <h2>${labels.exhibitionPreface}</h2>
          <div class="content-area">${getContent('preface')}</div>
        </div>
        `
            : ''
        }

        <!-- Artist Bio -->
        ${
          getContent('artist_bio')
            ? `
        <div class="page">
          <h2>${labels.artistBio}</h2>
          <div class="content-area">${getContent('artist_bio')}</div>
        </div>
        `
            : ''
        }

        <!-- Artworks -->
        ${
          artworks && artworks.length > 0
            ? `
        <div class="page">
          <h2>${labels.artworks}</h2>
          <div class="artworks-grid">
            ${artworks.map((artwork: any, index: number) => {
              const displayTitle = artwork.title || `${labels.artwork} ${index + 1}`
              return `
              <div class="artwork-item">
                ${artwork.image_url ? `<img src="${artwork.image_url}" alt="${displayTitle}">` : ''}
                <div class="artwork-title">${displayTitle}</div>
                ${artwork.description ? `<div class="artwork-desc">${artwork.description}</div>` : ''}
              </div>
              `
            }).join('')}
          </div>
        </div>
        `
            : ''
        }

        <!-- Press Release -->
        ${
          getContent('press_release')
            ? `
        <div class="page">
          <h2>${labels.pressRelease}</h2>
          <div class="content-area">${getContent('press_release')}</div>
        </div>
        `
            : ''
        }

        <!-- Marketing Report -->
        ${
          getContent('marketing_report')
            ? `
        <div class="page">
          <h2>${labels.marketingReport}</h2>
          <div class="content-area">${getContent('marketing_report')}</div>
        </div>
        `
            : ''
        }
      </body>
      </html>
    `

    // Launch Puppeteer - detect environment
    console.log('[PDF] Launching browser...')
    const isDev = process.env.NODE_ENV === 'development'

    try {
      if (isDev) {
        // Local development - use regular puppeteer
        const puppeteerFull = await import('puppeteer')
        browser = await puppeteerFull.default.launch({
          headless: true,
          args: ['--no-sandbox', '--disable-setuid-sandbox'],
        })
      } else {
        // Production (Vercel) - use puppeteer-core with remote chromium
        console.log('[PDF] Fetching Chromium executable...')
        const executablePath = await chromium.executablePath(CHROMIUM_URL)
        console.log('[PDF] Chromium path:', executablePath)
        browser = await puppeteer.launch({
          args: chromium.args,
          defaultViewport: {
            width: 1920,
            height: 1080,
          },
          executablePath,
          headless: true,
        })
      }
    } catch (browserError: any) {
      console.error('[PDF] Failed to launch browser:', browserError)
      const errorMsg = locale === 'en'
        ? 'PDF generation service unavailable. Please try again later.'
        : 'PDF 생성 서비스를 시작할 수 없습니다. 잠시 후 다시 시도해주세요.'
      return NextResponse.json(
        { error: errorMsg },
        { status: 503 }
      )
    }

    console.log('[PDF] Rendering HTML content...')
    const page = await browser.newPage()
    await page.setContent(htmlContent, {
      waitUntil: 'networkidle0',
      timeout: 30000, // 30 second timeout for content loading
    })

    console.log('[PDF] Generating PDF...')
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
      margin: {
        top: '60px',
        right: '60px',
        bottom: '60px',
        left: '60px',
      },
    })

    console.log('[PDF] PDF generated successfully')
    await browser.close()


    // Ensure the filename we send in headers stays ASCII while still providing original title
    const baseTitle = exhibition.title || 'document'
    const titleForFilename = `exhibition_${baseTitle}`
    const asciiFallback = titleForFilename
      .normalize('NFKD')
      .replace(/[^\u0000-\u007f]/g, '')
      .replace(/[^A-Za-z0-9._-]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_+|_+$/g, '')
    const safeFilename = (asciiFallback || 'exhibition_document') + '.pdf'
    const encodedFilename = encodeURIComponent(`${titleForFilename}.pdf`)

    // Return PDF
    return new NextResponse(Buffer.from(pdfBuffer), {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${safeFilename}"; filename*=UTF-8''${encodedFilename}`,
      },
    })
  } catch (error: any) {
    console.error('[PDF] Generate PDF error:', error)
    console.error('[PDF] Error stack:', error?.stack)

    if (browser) {
      try {
        await browser.close()
      } catch (closeError) {
        console.error('[PDF] Error closing browser:', closeError)
      }
    }

    // Provide more specific error messages based on locale
    // Note: locale may not be available if error occurred before parsing
    const errorLocale = requestBody?.locale || 'ko'
    const isEn = errorLocale === 'en'

    let errorMessage = isEn
      ? 'An error occurred while generating PDF.'
      : 'PDF 생성 중 오류가 발생했습니다.'
    if (error?.message?.includes('timeout')) {
      errorMessage = isEn
        ? 'PDF generation timed out. There may be too many or large images.'
        : 'PDF 생성 시간이 초과되었습니다. 이미지가 너무 많거나 크기가 클 수 있습니다.'
    } else if (error?.message?.includes('memory')) {
      errorMessage = isEn
        ? 'PDF generation failed due to memory shortage.'
        : '메모리 부족으로 PDF 생성에 실패했습니다.'
    }

    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    )
  }
}

